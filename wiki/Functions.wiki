#summary List of Functions
= 1D Functions =

===1. J-Level Discrete Wavelet Transform===
*{{{void* dwt(vector<double> &, int ,string , vector<double> &, vector<double> &)}}}*

Example Usage : *dwt(sig, J, nm, dwt_output,flag )*

where,

*sig :* is the input signal . It is a {{{vector<double>}}} object.

*J :* Number of DWT Levels. Integer.

*nm :* Name of Wavelet. See function filtcoef for more information. String.

*dwt_ouput:* is a {{{vector<double>}}} object that will return the DWT output.

*flag:* is a vector that contains two {{{vector<double>}}} values.

{{{flag[0]}}} - contains the number of zeros if the signal is zeropadded.

{{{flag[1]}}}- contains the number of decomposition levels. (J)

flag is used by IDWT to help process the DWT output.

Additional Outputs : In addition to above, the function also generates .txt and .dat files.

GNUPLOT ready .dat files

*gnusig.dat :* contains signal data

*gnufilt.dat:* Contains filters data.[All Four filters are arranged columnwise in the file]

*gnuout.dat :* Contains DWT coefficients. It stores approximation and detail coefficients columnwise in alternating fashion. For example, three level of approximation and detail coefficients will result in gnuout.dat having 7 columns. First column is index followed by alternating approximation and detail columns.

Text Files : These two files are used by the code to generate gnuout.dat file.

*appx.txt :* Values of Approximation Coefficients from each stage. Values are appended after each stage.

*det.txt :* Values of Detail Coefficients after each stage. Values are likewise appended after each stage.

*dwtout.txt:* Stores the DWT ouput in text format. It contains Approximation coefficients at Jth level, followed by detail coefficients at Jthe, J-1,.... level 1.

*flag.txt:* Contains values of flags in text format.

===2. 1-Level Discrete Wavelet Transform===

*{{{void* dwt1(string, vector<double> &, vector<double> &, vector<double> &)}}}*

Example Usage: *dwt1(nm,sig, appx_sig, det_sig)*

*nm :* Wavelet Name. String

*sig :* Input Signal. {{{Vector<double>}}} Object.

*appx_sig:* Approximation Coefficients. {{{Vector<double>}}} object.

*det_sig:* Detail Coefficients. {{{Vector<double>}}} object.

Same Functionality can be achieved by setting J=1 in the dwt function but dwt1 directly outputs detail and approximation coefficients for one level of decomposition. This function will not generate any of GNUPLOT files but may be preferable in any number of scenarios.

===3. Dyadic Zero-Padding===

*{{{void* dyadic_zpad_1d(vector<double> &)}}}*

Example Usage: *dyadic_zpad_1d(sig)*

It zeropads signal sig such that its length is now dyadic. For example a signal with length 195 will be zeropadded to 256.

===4. Convolution===

Recommended -- *{{{double convfft(vector<double> &, vector<double> &, vector<double> &)}}}* 

*-or-*

*{{{double convol(vector<double> &, vector<double> &, vector<double> &)}}}*

Example Usage: *convfft(signal,lpd,cA_undec)*

where, signal and lpd are two inputs that are convolved and the convolution output is stored in cA_undec. All three are {{{vector<double>}}} objects.

Important- *convfft* will not modify the value of signal while convol will. I have not corrected this as *convfft* is the faster, better implementation and should be used instead of *convol*.

===5. Filter Coefficients===

*{{{int filtcoef(string , vector<double> &, vector<double> &, vector<double> &, vector<double> &)}}}*

Example Usage: *filtcoef(nm,lpd,hpd,lpr,hpr)*

*nm:* Wavelet name.

*lpd:* Low Pass Decomposition Filter Coefficients.

*hpd:* High Pass Decomposition Filter Coefficients.

*lpr:* Low Pass Reconstruction Filter Coefficients.

*hpr:* High Pass Reconstruction Filter Coefficients.

All filters are {{{vector<double>}}} objects and can be obtained by specifying the wavelet name. Currently, following Wavelets are available:

Daubechies : db1,db2,.., ,db15

Biorthogonal: bior1.1 ,bior1.3 ,bior1.5 ,bior2.2 ,bior2.4 ,bior2.6 ,bior2.8 ,bior3.1 ,bior3.3 ,bior3.5 ,bior3.7 ,bior3.9 ,bior4.4 ,bior5.5 ,bior6.8

Coiflets: coif1,coif2,coif3,coif4,coif5

===6. Downsampling===

*{{{void downsamp(vector<double> &, int , vector<double> &)}}}*

Example Usage : *downsamp(cA_undec, D, cA)*

*cA_undec:* Signal to be downsampled. {{{Vector<double>}}}

*D :* Downsampling Factor. Integer

*cA:* Downsampled Signal. {{{Vector<double>}}}

===7. Upsampling===

*{{{void upsamp(vector<double> &, int, vector<double> &)}}}*

Example Usage : *upsamp(cA, U, cA_up)*

*cA:* Signal to be upsampled. {{{Vector<double>}}}

*U :* Upsampling Factor. Integer

*cA_up:* Upsampled Signal. {{{Vector<double>}}}

===8. J-Level Inverse Discrete Wavelet Transform===

*{{{void* idwt(vector<double> &,vector<double> &, string , vector<double> &)}}}*

Example Usage: *idwt(dwt_output, flag,nm,output)*

*dwt_output:* Output of DWT which serves as Input to the IDWT. {{{vector<double>}}}

*flag:* Contains values of J and zeropadding. {{{vector<double>}}}

*nm :* Wavelet name. String

*output:* Reconstructed IDWT Output. {{{vector<double>}}}

Additional .dat output

*gnurecon.dat :* GNUPLOT ready reconstructed signal.

===9. 1-Level Inverse Discrete Wavelet Transform===

*{{{void* idwt1(string wname, vector<double> &, vector<double> &, vector<double> &)}}}*

Example Usage : *idwt1(nm,idwt_output, app,detail)*

*nm:* Wavelet Name.

*idwt_output:* Outputs IDWT.

*app:* Approximation Coefficients.

*detail:* Detail Coefficients.

===10. GNUDWTPLOT===

*{{{void* gnudwtplot(int)}}}*

Example Usage: *gnudwtplot(J)*

Generates GNUPLOT script gnudwt.gnu.txt that contains plots of signals, filters and wavelet coefficients. it works if it is called following DWT and IDWT operations. To draw the plots, just load the script in gnuplot. See wavedemo1.cpp for more details.

        

= 1D Symmetric Extension DWT Functions =

===11. J-Level Symmetric Extension DWT===

*{{{void* dwt_sym(vector<double> &, int ,string , vector<double> &,vector<double> &,vector<int> &, int );}}}*

Example Usage: *dwt_sym (signal, J,nm, dwt_output, flag,length, e)*

Same as *dwt* function except it contains two more arguments and the output is a 1D vector. *length* is an integer vector which contains lengths of approximation and detail coefficients. *e* is the length of symmetric extension in each direction. *dwt_output* stores coefficients in following format:
*{{{[A(J) D(J) D(J-1) ..... D(1)]}}}*

 where *A(J)* is the approximation coefficient vector at the Jth level while *D(n)* are the detail coefficient vectors at the nth level. *length* contains the lengths of corresponding vectors. Last entry of the *length* vector is the length of the original signal.

=== 12. J-Level Symmetric Extension IDWT===

*{{{void* idwt_sym(vector<double> &,vector<double> &, string,vector<double> &, vector<int> &);}}}*

Example Usage: *idwt_sym(dwtop,flag,nm,idwt_output,length) *

*idwt_sym* is identical to *idwt* above except that it contains one more argument in lengths of the coefficients vector *length*. It is the same vector described in *11*.

=== 13. Symmetric Extension ===

*{{{void* symm_ext(vector<double> &, int )}}}*

Example Usage: *symm_ext(signal,e)*

*symm_ext* symmetrically extends the signal by length e in either direction.

=1D Stationary Wavelet Transform=

=== 14. J-Level Stationary Wavelet Transform ===

*{{{void* swt(vector<double> &, int , string , vector<double> &, int &) }}}*

Example Usage: *swt(sig,J,nm,swt_output,length)*

This function works on dyadic length signal. All the coefficients are of equal lengths and that value is stored in *length*. *swt_output* stores value in the same format as *11* - Approximation coefficient vector at level J is stored at the beginning of the *swt_output* vector followed by detail coefficients vectors at levels J, J-1,...., 1. Additionally, ALL coefficient vectors(including redundant approximation vectors) are stored in *gnuout.dat* file. See *gnuswtplot* for more details.

=== 15. J-Level Inverse Stationary Wavelet Transform ===

*{{{void* iswt(vector<double> &,int , string, vector<double> &)}}}*

Example Usage: *iswt(swtop,J,nm,iswt_output)*

*swtop* is the output of SWT stage , J - number of levels and nm is the wavelet as before. Output of ISWT is stored in *iswt_output* vector.

=== 16. GNUSWTPLOT ===

*{{{void* gnuswtplot(int)}}}*

Example Usage: *gnuswtplot(J)*

Generates GNUPLOT script gnudwt.gnu.txt that contains plots of signals, filters and wavelet coefficients. it works if it is called following SWT and ISWT operations. To draw the plots, just load the script in gnuplot.

=== 17. 1D Periodic Extension ===

*{{{void* per_ext(vector<double> &, int )}}}*

Example Usage: *per_ext(sig,a)*

*per_ext* periodically extends the signal *sig* by value *a* in either direction.

= 2D Functions =

There are three sets of 2D DWT options.

1. Regular decimated 2D DWT and IDWT. It works with dyadic length 2D signals and outputs 2D signals.(The DWT output is in the format of a dyadically decomposed image with cLL, the low pass output, in the top left corner) If the input signal isn't of dyadic length then it will be zeropadded and you can calculate output size by using *dwt_output_dim* function and remove zeros from the output by using the *sero_remove* function. More on this will follow. For a N X N dydadic length signal, the output is N X N which is useful in many applications.

https://lh5.googleusercontent.com/_TwtGvT0Ma-0/Tbk_OaFazJI/AAAAAAAAABI/N9CQwURPJfs/ezw.png

2. Symmetric Extension 2D DWT and IDWT signal. It works with signal of any length and DWT output is a 1D vector (just as in Matlab) which may make it easier to handle in certain situations. On the flip side, the output is not of the same size as input and so there are some redundancies. To display the image, you'll have to convert 1D vector into image format and also account for downsampling and convolution which result in non-linear variation of length across deocmposition levels. The functions *dispDWT* and *dwt_output_dim_sym* will help in displaying the image. On the flip side, performing operations on 1D 
DWT output vector should be straightforward.

3. 2D Stationary Wavelet Transform. Inverse Stationary Transform is not implemented as of yet but 2d SWT should be good for image analysis, pattern recognition and edge detection operations that don't require ISWT for the most part.

=== 18. J-Level 2D Discrete Wavelet Transform===

*{{{void* dwt_2d(vector<vector<double> > &, int , string , vector<vector<double> > &, vector<double> &)}}}*

Example Usage: *dwt_2d(vec1, J, nm, dwt_output,flag )*

*vec1* is the 2D input signal.

*J* is the Decomposition level.

*nm* gives the name of wavelet family. See *filtcoef* for more details.

*dwt_output* is the 2D output coefficients. They are arranged as shown in the figure above. The dimensions can be obtained by using *dwt_output_dim* function. A code fragment may look like this-
 {{{
  int rr1,cc1;
  string nm = "db4";
  // Finding DWT output dimensions as the DWT output is zeropadded
  dwt_output_dim(vec1, rr1, cc1 );// vec1 is the input image/matrix
  int J = 2;
  vector<double> flag;// Flag stores values including size of input and level of decomposition and this vector needs to be passed to idwt_2d function.
  vector<vector<double> >  dwt_output(rr1, vector<double>(cc1));
  // Computing 2d DWT ( vec1is the signal while dwt_output is the DWT   output)
  dwt_2d(vec1, J, nm, dwt_output,flag );}}}