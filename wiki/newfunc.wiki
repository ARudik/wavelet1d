=List of Functions for wavelet2d Library=

== 1D DWT/IDWT Functions ==

Both periodic and symmetric extension methods for Decimated DWT take exactly same input arguments.The difference is that Output vector in periodic extension has usually the same size (~N) as the input vector(N) while output vector in symmetric extension case has redundancies with length depending on size of filter used.

=== Periodic Extension===

*1. DWT:*  {{{void* dwt(vector<double> &sig, int J, string nm, vector<double> &dwt_output,vector<double> &flag, vector<int> &length )}}}

where,

_*sig*_ :: _Input Signal vector_

_*J*_ :: _Decomposition levels_

_*nm*_ :: _Wavelet Name_ _(See filtcoef for available wavelet families)_

_*length*_ :: _Lengths of respective approximation and detail vectors are stored in this integer vector._

_*dwt_output*_ :: _Output of Discrete Wavelet Transform. It stores coefficients in following format:_

*{{{[A(J) D(J) D(J-1) ..... D(1)]}}}*

_ where *A(J)* is the approximation coefficient vector at the Jth level while *D(n)* are the detail coefficient vectors at the nth level. _*length*_ contains the lengths of corresponding vectors. Last entry of the _*length*_ vector is the length of the original signal._

_*flag*_ :: _Housekeeping vector. In this implementation it contains two values-_

_flag[0] is 0 if the signal is even and it is 1 if signal is odd and if it is made even by repeating the last value one more time_

_flag[1] - contains the decomposition levels._

_Housekeeping vector is a double vector as it was originally meant to store more values than it currently does_

[https://lh3.googleusercontent.com/-axX5BI71K7k/Tk7CvelHwrI/AAAAAAAAALI/Tc9h_KznCgM/s912/dwtperscreen.png]
_DWT stats (periodic extension) for an input signal of length 256_



*2. IDWT:* {{{void* idwt(vector<double> &dwtop,vector<double> &flag, string nm,vector<double> &idwt_output,vector<int> &length)}}}

where,

_*dwtop*_ :: _is the DWT vector_

_*flag*_ :: _Same Housekeeping function as obtained from the DWT function_

_*nm*_ :: _Wavelet Used_

_*idwt_output*_ :: _Output of IDWT_

_*length*_ :: _Length vector obtained from the DWT computations_

===Symmetric Extension===

*3. DWT:*  {{{void* dwt_sym(vector<double> &sig, int J, string nm, vector<double> &dwt_output,vector<double> &flag, vector<int> &length )}}}

where,

_*sig*_ :: _Input Signal vector_

_*J*_ :: _Decomposition levels_

_*nm*_ :: _Wavelet Name_ _(See filtcoef for available wavelet families)_

_*length*_ :: _Lengths of respective approximation and detail vectors are stored in this integer vector._

_*dwt_output*_ :: _Output of Discrete Wavelet Transform. It stores coefficients in following format:_

*{{{[A(J) D(J) D(J-1) ..... D(1)]}}}*

_ where *A(J)* is the approximation coefficient vector at the Jth level while *D(n)* are the detail coefficient vectors at the nth level. _*length*_ contains the lengths of corresponding vectors. Last entry of the _*length*_ vector is the length of the original signal._

_*flag*_ :: _Housekeeping vector. In this implementation it contains two values-_

_flag[0] is 0 if the signal is even and it is 1 if signal is odd and if it is made even by repeating the last value one more time_

_flag[1] - contains the decomposition levels._

_Housekeeping vector is a double vector as it was originally meant to store more values than it currently does_

_*idwt_output*_ :: _Output of the Inverse Discrete Wavelet Transform_

_*length*_ :: _Length Vector Obtained from the DWT computations_ 

[https://lh5.googleusercontent.com/-rooeVHG4pdc/Tk7FP_sPOTI/AAAAAAAAALQ/xWTasj0blNE/s912/dwtsymscreen.png]
_DWT stats (symmetric extension) for an input signal of length 256_

*4. IDWT:* {{{void* idwt_sym(vector<double> &dwtop,vector<double> &flag, string nm,vector<double> &idwt_output,vector<int> &length)}}}

where,

_*dwtop*_ :: _is the DWT vector_

_*flag*_ :: _Same Housekeeping function as obtained from the DWT function_

_*nm*_ :: _Wavelet Used_

_*idwt_output*_ :: _Output of IDWT_

_*length*_ :: _Length vector obtained from the DWT computations_

==1D SWT/ISWT Functions==

*5. SWT:* {{{void* swt(vector<double> &sig, int J, string nm, vector<double> &swt_output, int &length)}}}

 All the coefficients are of equal lengths and that value is stored in _*length*_. _*swt_output*_ stores value in the same format as _*dwt*_ and _*dwt_sym*_ functions - Approximation coefficient vector at level J is stored at the beginning of the *swt_output* vector followed by detail coefficients vectors at levels J, J-1,...., 1.

[https://lh6.googleusercontent.com/-LrlkA6bwApU/Tk7QyJDP7LI/AAAAAAAAALU/tJCOQXWxpiE/s912/swtscreen.png]
_Two Level SWT Decomposition of a 247 length signal vector_

*6. ISWT:* {{{void* iswt(vector<double> &swtop,int J, string nm, vector<double> &iswt_output)}}}


_*swtop*_ is the output of SWT stage , _*J*_ - number of levels and _*nm*_ is the wavelet as before. Output of ISWT is stored in _*iswt_output*_ vector.

== 2D DWT/IDWT Functions ==

As in 1D case, both periodic and symmetric extension methods for Decimated DWT take exactly same input arguments.The difference is that Output vector in periodic extension has usually the same size (~NXN) as the input vector(NXN) while output vector in symmetric extension case has redundancies with length/breadth depending on size of filter used.